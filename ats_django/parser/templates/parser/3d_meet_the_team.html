<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Rounded Cube - Picture-in-Picture Camera</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #f0f0f0;
        }
        canvas {
            display: block;
            cursor: pointer;
        }
        /* NEW: Style for the map view container */
        #map-view {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 200px;
            height: 200px;
            background-color: rgba(255, 255, 255, 0.3);
            border: 1px solid #ccc;
            pointer-events: none; /* Allows clicking through it */
        }
    </style>
</head>
<body>
    <div id="map-view"></div>
    <canvas id="webgl-canvas"></canvas>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';

        // 1. Core Three.js Setup
        const scene = new THREE.Scene();

        // --- NEW: Define map view size ---
        const mapWidth = 200, mapHeight = 200;

        // --- Main Camera (Your "eye") ---
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 4;

        // --- NEW: Map Camera (Looks down at the scene) ---
        const cameraMap = new THREE.PerspectiveCamera(60, mapWidth / mapHeight, 0.1, 1000);
        cameraMap.position.set(0, 10, 0); // Positioned high up
        cameraMap.lookAt(scene.position); // Looking at the center (0,0,0)

        const renderer = new THREE.WebGLRenderer({
            canvas: document.getElementById('webgl-canvas'),
            alpha: true,
            antialias: true 
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        
        // 2. Add OrbitControls for the MAIN camera
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; 
        controls.enableZoom = false; 
        controls.autoRotate = true; 
        controls.autoRotateSpeed = 2.0;

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let isAnimating = false;
        const targetRotation = new THREE.Quaternion();

        // 3. Textures and Materials
        const imageUrls = [];
        for (let i = 0; i < 6; i++) {
            imageUrls.push(`https://picsum.photos/300/300?random=${i}`);
        }
        const textureLoader = new THREE.TextureLoader();
        const materials = imageUrls.map(url => {
            return new THREE.MeshBasicMaterial({
                map: textureLoader.load(url),
                side: THREE.DoubleSide 
            });
        });

        // 4. Geometry and Mesh
        const geometry = new RoundedBoxGeometry(2, 2, 2, 6, 0.05); 
        const cube = new THREE.Mesh(geometry, materials);
        scene.add(cube);

        // --- NEW: Create the camera helper sphere ---
        const sphereGeometry = new THREE.SphereGeometry(0.2, 16, 16); 
        const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 }); // Yellow
        const cameraHelperSphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
        scene.add(cameraHelperSphere); // Add it to the scene

        // 5. Animation Loop
        function animate() {
            requestAnimationFrame(animate);

            controls.update();

            // --- NEW: Update the helper sphere position ---
            // This is now correct, because we'll see it from the *map* camera
            cameraHelperSphere.position.copy(camera.position);

            if (isAnimating) {
                cube.quaternion.slerp(targetRotation, 0.05);
                if (cube.quaternion.angleTo(targetRotation) < 0.01) {
                    cube.quaternion.copy(targetRotation);
                    isAnimating = false;
                }
            }

            // --- NEW: Enable Scissor Test ---
            // This allows us to render to a specific "scissor" rectangle
            renderer.setScissorTest(true);

            // --- Render Main Scene (Full window) ---
            renderer.setScissor(0, 0, window.innerWidth, window.innerHeight);
            renderer.setViewport(0, 0, window.innerWidth, window.innerHeight);
            renderer.render(scene, camera);

            // --- Render Map Scene (Bottom-left corner) ---
            // The 20, 20 offsets match the CSS for the div
            renderer.setScissor(20, 20, mapWidth, mapHeight);
            renderer.setViewport(20, 20, mapWidth, mapHeight);
            renderer.render(scene, cameraMap); // Render with the map camera

            // --- NEW: Disable Scissor Test ---
            renderer.setScissorTest(false);
        }

        // 6. Handle Window Resizing
        window.addEventListener('resize', () => {
            // Update main camera
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            // --- NEW: Update map camera aspect ratio ---
            // We keep its size fixed, so no change needed here unless
            // you make the map view responsive.

            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        });

        // 7. Handle Click Event
        function onClick(event) {
            // --- NEW: Check if click is inside map view ---
            // If it is, ignore the click so we don't rotate the cube
            const mapBox = document.getElementById('map-view').getBoundingClientRect();
            if (
                event.clientX >= mapBox.left && event.clientX <= mapBox.right &&
                event.clientY >= mapBox.top && event.clientY <= mapBox.bottom
            ) {
                return; // Click was inside map, do nothing
            }

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects([cube]);

            if (intersects.length > 0) {
                const intersect = intersects[0];
                if (intersect.face) {
                    const faceNormal = intersect.face.normal;
                    const targetVector = new THREE.Vector3(0, 0, 1); 

                    const startQuaternion = cube.quaternion.clone();
                    const tempMatrix = new THREE.Matrix4();
                    tempMatrix.makeRotationFromQuaternion(startQuaternion);
                    const worldNormal = faceNormal.clone().applyMatrix4(tempMatrix).normalize();

                    targetRotation.setFromUnitVectors(worldNormal, targetVector);
                    targetRotation.multiply(startQuaternion);

                    controls.autoRotate = false;
                    isAnimating = true;
                }
            }
        }
        window.addEventListener('click', onClick);

        // Start the animation
        animate();
    </script>
</body>
</html>