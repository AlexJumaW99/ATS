<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Rounded Cube - Click to Face</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #f0f0f0;
        }
        canvas {
            display: block;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <canvas id="webgl-canvas"></canvas>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        // NEW: Import the geometry for rounded edges
        import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';

        // 1. Core Three.js Setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({
            canvas: document.getElementById('webgl-canvas'),
            alpha: true,
            // NEW: This enables anti-aliasing to smooth pixelated edges
            antialias: true 
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        // NEW: This renders at your device's native screen resolution (for HDPI/Retina)
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        
        // 2. Add OrbitControls for interactivity
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; 
        controls.enableZoom = false; 
        controls.autoRotate = true; 
        controls.autoRotateSpeed = 2.0;

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let isAnimating = false;
        const targetRotation = new THREE.Quaternion();

        // 3. Textures and Materials
        const imageUrls = [];
        for (let i = 0; i < 6; i++) {
            imageUrls.push(`https://picsum.photos/300/300?random=${i}`);
        }

        const textureLoader = new THREE.TextureLoader();
        const materials = imageUrls.map(url => {
            return new THREE.MeshBasicMaterial({
                map: textureLoader.load(url),
                side: THREE.DoubleSide 
            });
        });

        // 4. Geometry and Mesh
        // NEW: Use RoundedBoxGeometry(width, height, depth, segments, radius)
        const geometry = new RoundedBoxGeometry(2, 2, 2, 6, 0.05); 
        const cube = new THREE.Mesh(geometry, materials);
        scene.add(cube);

        // Position the camera
        camera.position.z = 4;

        // 5. Animation Loop
        function animate() {
            requestAnimationFrame(animate);

            controls.update();

            if (isAnimating) {
                cube.quaternion.slerp(targetRotation, 0.05);
                if (cube.quaternion.angleTo(targetRotation) < 0.01) {
                    cube.quaternion.copy(targetRotation);
                    isAnimating = false;
                }
            }
            renderer.render(scene, camera);
        }

        // 6. Handle Window Resizing
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            // NEW: Also update the pixel ratio on resize
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        });

        // 7. Handle Click Event
        function onClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects([cube]);

            if (intersects.length > 0) {
                const intersect = intersects[0];
                if (intersect.face) {
                    const faceNormal = intersect.face.normal;
                    const targetVector = new THREE.Vector3(0, 0, 1); 

                    // Clone the cube's current world quaternion to start from
                    const startQuaternion = cube.quaternion.clone();

                    // Create a temporary matrix to get the face's world-space normal
                    const tempMatrix = new THREE.Matrix4();
                    tempMatrix.makeRotationFromQuaternion(startQuaternion);
                    const worldNormal = faceNormal.clone().applyMatrix4(tempMatrix).normalize();

                    // Calculate the rotation needed to align the world normal with the target vector
                    targetRotation.setFromUnitVectors(worldNormal, targetVector);

                    // Combine with the cube's current rotation
                    targetRotation.multiply(startQuaternion);

                    controls.autoRotate = false;
                    isAnimating = true;
                }
            }
        }
        window.addEventListener('click', onClick);

        // Start the animation
        animate();
    </script>
</body>
</html>